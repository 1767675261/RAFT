下面按你给定的严格规范完成两步输出。要素提取基于你提供的测试用例与规则文档（已读入）。 

---

## Step1 — 规则要素清单（15 项）

> 说明：每项为 **叶子类名（UpperCamelCase）**，后附 10 字以内语义说明。

1. **Actor** — 执行操作的主体
2. **VehicleCategory** — 车辆/主体类别
3. **Certificate** — 必要凭证/证照
4. **Condition** — 触发或存在的条件
5. **Location** — 发生/适用的位置
6. **TimeDuration** — 时间或期限要素
7. **Constraint** — 通用约束/限制条件
8. **Action** — 具体操作/行为
9. **Object** — 操作对象/目标实体
10. **Speed** — 速度量值或速限
11. **Direction** — 行驶/动作方向
12. **Distance** — 距离/间隔量（例如警示距离）
13. **LoadWeight** — 载重/载客/载货量
14. **Result** — 预期结果/合规性结果
15. **FineAmount** — 罚款/量化处罚金额

---

## Step2 — 三层元模型（PlantUML）

下面给出完整 **三层树状类图**，顶层 `Rule`，中层固定三节点 `Precondition` / `Operation` / `ExpectedResult`，底层直接使用 Step1 中的叶子类名（**名称一致**）。所有中间关系与叶子关系已标注关系名（小写动词）。
（注意：类体保持空白；每条关系标注了关系名；底层要素仅被包含到单一中层节点。）

```plantuml:disable-run
@startuml
' --- 顶层与中层类（类体空白） ---
class Rule {}
class Precondition {}
class Operation {}
class ExpectedResult {}

' --- 底层叶子类（与 Step1 名称完全一致） ---
class Actor {}
class VehicleCategory {}
class Certificate {}
class Condition {}
class Location {}
class TimeDuration {}
class Constraint {}
class Action {}
class Object {}
class Speed {}
class Direction {}
class Distance {}
class LoadWeight {}
class Result {}
class FineAmount {}

' --- Rule 包含三大部分 ---
Rule --> Precondition : contains
Rule --> Operation : contains
Rule --> ExpectedResult : contains

' --- Precondition 包含的叶子（仅属于 Precondition） ---
Precondition --> Actor : contains
Precondition --> VehicleCategory : contains
Precondition --> Certificate : contains
Precondition --> Condition : contains
Precondition --> Location : contains
Precondition --> TimeDuration : contains
Precondition --> Constraint : contains

' --- Operation 包含的叶子（仅属于 Operation） ---
Operation --> Action : contains
Operation --> Object : contains
Operation --> Speed : contains
Operation --> Direction : contains
Operation --> Distance : contains
Operation --> LoadWeight : contains

' --- ExpectedResult 包含的叶子（仅属于 ExpectedResult） ---
ExpectedResult --> Result : contains
ExpectedResult --> FineAmount : contains

' --- 叶子间的语义关系（类型为规定动词，便于测试/验证规则逻辑） ---
' 驾驶主体通常依赖于有效凭证
Actor --> Certificate : dependsOn

' 约束会限制操作（例如“禁止超车”）
Constraint --> Action : constrains

' 地点（如高速）决定速度限制
Location --> Speed : constrains

' 距离（例如警示距离）约束具体操作执行（如设置标志）
Distance --> Action : constrains

' 车辆类别约束载重/载客上限
VehicleCategory --> LoadWeight : constrains

' 时间期限（如暂扣期）约束主体可否执行某操作
TimeDuration --> Actor : constrains

' 操作触发预期结果（如"停车"触发合规或处罚）
Action --> Result : triggers

' 速度违规会影响结果（例如超速导致违规判定）
Speed --> Result : constrains

@enduml
```

---

### 说明与设计理由（简要）

* 叶子数为 **15**，均为可测试、可量化或可判定的要素，优先从你提供的测试用例抽取并与法规语义对齐（参见上传的 `testcase_traffic.json` 与法规文本）。 
* 三层严格遵守：`Rule` → {`Precondition`,`Operation`,`ExpectedResult`} → 叶子要素。每个叶子**只被包含到一个中层节点**（满足可机读的单一责任划分），但允许叶子之间建立语义关系（`constrains`/`dependsOn`/`triggers` 等），以表达运行时依赖与限制。
* 叶子命名使用 **UpperCamelCase**，类体为空，关系名使用小写动词，PlantUML 中已逐一标注，适合直接用于自动化解析或生成测试模板。

---

如果你要我：

* 把这份 PlantUML 转为 PNG/SVG，或在模型上自动映射你现有测试用例到叶子要素并输出覆盖矩阵，我可以立刻生成（会直接在本次回复中产出结果，不做异步处理）。
* 或者你希望我调整某些叶子（合并/拆分）以匹配更具体的子领域（例如区分“驾驶人”与“车辆”为两个 Actor 角色），请直接指出我要修改的叶子名称，我将按你的新偏好更新元模型。



你是一名 **软件需求建模与测试专家**。
你的任务是：**定义一种用于描述可测试规则的形式化语言（Testable Rule Language, TRL）**。
该语言旨在将自然语言规则或需求文档形式化，使其能够被自动解析、验证和生成测试用例。

---

### 输入

你将获得以下三类输入：

1. **规则/需求文档** —— 包含领域规则或系统行为的自然语言描述；
2. **测试用例** —— 对应文档中规则的实际测试样例；
3. **元模型语法结构** —— 描述规则由哪些要素组成及其层级关系。

---

### 任务目标

请基于以上输入，**定义完整的可测试规则语言 TRL**。
语言定义包括 **四个部分：符号 (Symbols)、语法 (Syntax)、语义 (Semantics)、可测试性约束 (Testability Constraints)**。
每个部分的要求如下：

---

### **符号系统 (Symbols)**

* 以给定的元模型为基础，定义语言中使用的符号类型与作用范围，包括：
  * **逻辑符号**
  * **比较符号**
  * **领域符号**
* 明确每类符号的语法位置与语义角色。

---

### **语法 (Syntax)**

* 以给定的元模型为基础，定义语言的核心组成单元，同时指出这些单元的层次结构与组合规则；
* 每个元素的值应该是字符串或数字，不能是enum；
* 使用形式化BNF表示定义语言结构，顶层结构为下面格式，禁止修改；
  ```
  Rule ::= "IF" <Condition> "AND" <Action> "THEN" <ExpectedOutcome>
  ```
* 语法定义尽量简单直接，但要支持复杂规则（如同一要素或不同要素间的与或非、嵌套条件、复合动作）；
* Condition、Action和ExpectedOutcome应该具有一致的表达形式，相同的结构风格。

---

### **语义 (Semantics)**

* 定义每个语法要素和符号的语义解释；
* 说明如何从语言表达式推导出系统可执行行为：
  * 条件部分映射为输入约束；
  * 动作部分映射为操作序列；
  * 预期结果映射为断言；
* 可使用**操作语义 (Operational Semantics)** 或 **模型语义 (Denotational Semantics)** 表示；

---

### **可测试性约束 (Testability Constraints) — 保证可测试性**

* 定义一组形式化约束，确保规则模型满足**可测试性条件**。你需要根据已有的知识结合文档、测试用例等全面定义可测试规则的条件，并以OCL进行形式化表示。

---

### **输出要求**

请输出以下内容：

1. **符号、语法、语义、可测试性约束每部分的形式化表示**；
2. **TRL 的完整定义**；
3. **一个示例**：展示如何将自然语言规则转化为该语言实例，并判断是否满足可测试性。


### 元模型（PlantUML表示）
@startuml
class Rule
class Precondition
class Operation
class ExpectedResult

class Actor
class VehicleType
class Condition
class Location
class Credential
class Event
class Time
class Action
class Speed
class Distance
class Target
class Direction
class Outcome
class Amount

Rule --> Precondition : contains
Rule --> Operation : contains
Rule --> ExpectedResult : contains


Precondition --> Actor : contains
Precondition --> VehicleType : contains
Precondition --> Condition : contains
Precondition --> Location : contains
Precondition --> Credential : contains
Precondition --> Event : contains
Precondition --> Time : contains

Operation --> Action : contains
Operation --> Target : contains
Operation --> Speed : contains
Operation --> Distance : contains
Operation --> Direction : contains


ExpectedResult --> Amount : contains
ExpectedResult --> Outcome : contains
@enduml

# TRL（Testable Rule Language）完整定义 — 软件需求建模与测试专家版

下面给出基于你提供的元模型的 **可测试规则语言 TRL** 的完整形式化定义（符号 / 语法 / 语义 / 可测试性约束），并用来自你上传的**道路交通安全法**与 **测试用例** 的实例演示转换与可测试性判断。引用的原始文件：中华人民共和国道路交通安全法（已上传）。 测试用例文件 `testcase_traffic.json`（已上传）。

---

# 1. 符号系统（Symbols）

基于给定元模型（Rule 包含 Precondition、Operation、ExpectedResult，Precondition 包含 Actor、VehicleType、Condition、Location、Credential、Event、Time；Operation 包含 Action、Target、Speed、Distance、Direction；ExpectedResult 包含 Amount、Outcome）定义 TRL 的符号类别与作用域。

## 1.1 符号分类

* **逻辑符号**

  * `AND`, `OR`, `NOT`, `(`, `)`
  * 作用域：连接 Condition 子谓词、复合 Action 条件、ExpectedOutcome 复合断言。
  * 语法位置：只出现在 `<Condition>`、`<Action>`、`<ExpectedOutcome>` 的内部表达式中，用于连接基本原子谓词。

* **比较符号**

  * `=`, `!=`, `<`, `<=`, `>`, `>=`, `IN`, `NOT IN`, `CONTAINS`, `MATCHES`
  * 作用域：对属性值（字符串或数字）做比较或集合测试（注意：属性值**只能是字符串或数字**，**禁止**使用 enum）。
  * 语法位置：原子谓词（atomic predicate）中，例如 `Speed > 80`、`Location = "高速公路"`、`Actor MATCHES "驾驶.*"`。

* **领域符号（域名/属性名）**

  * 来自元模型的属性名，均视为标识符（字符串），**不能**被当成 enum 值：

    * `Actor`, `VehicleType`, `Condition`, `Location`, `Credential`, `Event`, `Time`,
    * `Action`, `Target`, `Speed`, `Distance`, `Direction`,
    * `Outcome`, `Amount`
  * 作用域：构建原子谓词与赋值（例如 `Actor = "机动车"`、`Speed = 80`）。
  * 语法位置：出现在原子谓词左侧或赋值位置。

## 1.2 语义角色（简述）

* 逻辑符号：构造布尔组合
* 比较符号：对输入参数做约束判断（Condition 中转为输入约束；ExpectedOutcome 中做断言）
* 领域符号：绑定元模型概念到具体字符串/数字值（例如 `"机动车"`、`150`）

---

# 2. 语法（Syntax，BNF）

**注意**：顶层结构严格保留（不可改）：

```
Rule ::= "IF" <Condition> "AND" <Action> "THEN" <ExpectedOutcome>
```

下述 BNF 在此基础上对 `<Condition>`、`<Action>`、`<ExpectedOutcome>` 统一定义为相同的“谓词组合结构”（满足题目：一致的表达形式），并支持嵌套/复合逻辑。

```
<Rule> ::= "IF" <ConditionExpr> "AND" <ActionExpr> "THEN" <OutcomeExpr>

<ConditionExpr> ::= <Expr>
<ActionExpr>    ::= <Expr>
<OutcomeExpr>   ::= <Expr>

<Expr> ::= <Atom>
         | "(" <Expr> ")"
         | <Expr> "AND" <Expr>
         | <Expr> "OR" <Expr>
         | "NOT" <Expr>

<Atom> ::= <Field> <Comparator> <Value>
         | <Field> "IN" "(" <ValueList> ")"
         | <Field> "CONTAINS" <Value>
         | <Field> "MATCHES" <Regex>

<Field> ::= "Actor" | "VehicleType" | "Condition" | "Location" | "Credential" | "Event" | "Time"
          | "Action" | "Target" | "Speed" | "Distance" | "Direction"
          | "Outcome" | "Amount"

<Comparator> ::= "=" | "!=" | "<" | "<=" | ">" | ">="

<Value> ::= STRING | NUMBER

<ValueList> ::= <Value> ("," <Value>)*

<Regex> ::= STRING   -- 正则表达式以字符串形式表示（实现端解释）

-- 额外约束：
-- 1) 所有 <Value> 必须是字符串或数字（禁止 enum）
-- 2) 同一 Rule 中出现的字段名数量不限（可重复出现）
```

**说明与设计要点**：

* Condition、Action、ExpectedOutcome 使用相同的表达式语法（`<Expr>`），满足“一致的表达形式” 的要求。
* 支持 `AND/OR/NOT`、括号用于嵌套复杂条件，`IN` 支持集合测试（集合元素仍为字符串/数字）。
* 所有叶值（Value）只能是 `STRING` 或 `NUMBER`（题目明确要求）。

---

# 3. 语义（Semantics）

我们采用**操作语义（Operational Semantics）**——将 TRL 映射为可执行检查流程：把 Condition 转为输入约束、Action 转为操作序列（模拟或 API 调用序列），ExpectedOutcome 转为断言（oracle）。下面给出形式化映射（伪数学/函数式表示）以及执行步骤。

## 3.1 记号

* 令 `Γ`（gamma）为系统状态空间（包括外部环境、设备状态、证件、时间等可观测变量）。
* 对任意字段 `f` 与值 `v`，谓词 `<Atom> := (f cmp v)` 表示布尔函数 `P_f,v : Γ -> {true,false}` 。

## 3.2 语义函数

* `⟦Atom⟧ : Γ -> Bool` —— 将原子谓词评估为布尔（用领域数据检查）。
* `⟦Expr⟧ : Γ -> Bool` —— 通过逻辑符号组合原子谓词的布尔结果（AND/OR/NOT/括号）。
* `⟦ConditionExpr⟧` 被解释为输入约束集合 `C = {p | p 为 Condition 中的原子谓词}`。
* `⟦ActionExpr⟧` 被解释为操作序列或触发动作模板 `A`。实现时将 Action 中的字段（Action、Target、Direction、Speed 等）映射成可执行步骤，例如：

  * 如果 `Action = "行驶"` 且 `Speed = 80`，则操作序列可表示为 `drive(speed=80, direction=...)`。
* `⟦OutcomeExpr⟧` 被解释为断言集合 `O = {o | o 为 ExpectedOutcome 中的原子谓词}`。

## 3.3 运行/验证流程（Operational）

给定一个规则 `R` 的 TRL 表达式 `IF C AND A THEN O`，以及系统模型/测试执行引擎 `E`：

1. **输入生成（Grounding）**

   * 从 `⟦ConditionExpr⟧` 取得输入约束 `C`（一组谓词）。根据每个谓词的字段和值（字符串/数字），生成或选择满足这些约束的具体输入向量 `I`（若谓词中包含变量/模糊值，使用策略如枚举边界、常见值或从测试用例中抽取具体值）。

2. **动作执行（Action）**

   * 将 `⟦ActionExpr⟧` 转换为可执行操作序列 `A_seq`（映射函数 `mapAction: Expr -> seq(Op)`），在测试环境中执行 `A_seq`，使系统进入某状态 `s'`.

3. **断言检查（Outcome）**

   * 对 `⟦OutcomeExpr⟧` 中每个断言在执行后状态 `s'` 上求值，若全部为真则规则验证成功（ExpectedOutcome 成立），否则失败。

4. **判定规则性质**

   * 如果存在能被生成的 `I` 与 `A_seq` 使得断言可被判定（真或假），则规则**可测试**（见可测试性约束）。否则为不可测试（例如 ExpectedOutcome 为自然语言含糊描述，不能映射为断言）。

## 3.4 形式化说明（示例）

* 对原子谓词 `Speed > 120`，`⟦Speed > 120⟧(γ)` 在系统状态 γ 上为真当且仅当 `γ.speed > 120`。
* 对 Action 原子 `Action = "设置" AND Target = "标志" AND Distance = 150`，`mapAction` 产出 `["placeWarning(distance=150)"]`（测试执行引擎需支持该动作）。

---

# 4. 可测试性约束（Testability Constraints） — OCL 表达

下面给出一组 OCL（对象约束语言）风格的约束，保证 Rule 能被自动解析、生成测试用例并判定结果。注：这些 OCL 约束基于元模型（Rule, Precondition, Operation, ExpectedResult 及其子属性）。

> 说明：这里的 OCL 使用常见表达约定（`context Class inv: ...`）。实现端可将这些约束转为实际校验器规则。

```ocl
-- 基本结构约束：Rule 必须包含至少一个前置条件，一个操作和一个预期结果
context Rule
inv: self.Precondition->notEmpty() and self.Operation->notEmpty() and self.ExpectedResult->notEmpty()

-- 值类型约束：所有叶子属性必须为 String 或 Number（禁止 enum）
context Rule
inv: self.allAttributes()->forAll(a | a.oclIsTypeOf(String) or a.oclIsTypeOf(Real) or a.oclIsTypeOf(Integer))

-- 条件可判定性：Condition 中每个原子谓词的字段必须属于元模型集（FieldSet），且比较符为支持集合
context Precondition
inv: self.getAtoms()->forAll(atom |
    Set{'Actor','VehicleType','Condition','Location','Credential','Event','Time'}->includes(atom.field)
)

-- 动作可执行性：Operation 中至少包含 Action 字段，且 Action 不为空字符串
context Operation
inv: self.Action <> '' and self.Action.oclIsTypeOf(String)

-- 预期结果可断言性：ExpectedResult 至少包含一项 Outcome 或 Amount 且每项是可判定（字符串或数值比较）
context ExpectedResult
inv: (self.Outcome <> null and self.Outcome.oclIsTypeOf(String)) or (self.Amount <> null and (self.Amount.oclIsTypeOf(Integer) or self.Amount.oclIsTypeOf(Real)))

-- 输入到动作映射约束（可生成输入）：所有 Condition 字段的值不能全部为模糊字符串 "ANY"（即需至少有一个具体值）
context Rule
inv: self.Precondition.getAtoms()->exists(atom | atom.value.oclIsTypeOf(String) or atom.value.oclIsTypeOf(Number))

-- 断言可比较性（Outcome 用数值比较或明确字符串匹配）
context ExpectedResult
inv: self.Outcome->forAll(o | o.matches('^[\\w\\s\\-]{1,200}$')) -- 简单约束：Outcome 为可匹配的短字符串

-- 不允许使用枚举字面量：任何属性值不得等于内置枚举标记（例如 "enum:xxx"）——实现端校验
context Rule
inv: self.allAttributes()->forAll(a | not a.toString().startsWith('enum:'))

-- 一致性约束：Rule 的 Condition 中引用的 Actor/VehicleType 出现在 Operation 或 ExpectedResult 中或为独立可观测实体
context Rule
inv: (self.Precondition.Actor->notEmpty() implies (self.Operation.Actor->notEmpty() or self.ExpectedResult.Outcome->notEmpty()))

-- 复杂性限额（实现可选）：避免无穷嵌套：Expr 嵌套深度 <= 6
context Rule
inv: self.getExprDepth() <= 6
```

这些 OCL 约束保证：

* 结构完整（有前置条件、动作、期望结果）；
* 所有叶值为字符串或数字（无 enum）；
* Condition / Action / ExpectedOutcome 是可判定和可执行的（包含具体值或能映射到系统操作/断言）；
* 不会出现过度嵌套导致自动化难以处理的情形。

---

# 5. TRL 的完整定义（汇总）

1. **符号系统**：逻辑符号 `{AND, OR, NOT, (, )}`；比较符号 `{=, !=, <, <=, >, >=, IN, CONTAINS, MATCHES}`；领域符号集合＝元模型属性名（Actor、VehicleType、...）。值类型仅限 `STRING` 或 `NUMBER`（禁止 enum）。
2. **语法**：以顶层 `Rule ::= "IF" <Condition> "AND" <Action> "THEN" <ExpectedOutcome>`；`Condition/Action/ExpectedOutcome` 皆采用统一的 `<Expr>` 结构（BNF 已给出），支持 `AND/OR/NOT` 与括号及原子比较。
3. **语义**：采用操作语义（Operational Semantics）：

   * `Condition` -> 输入约束（Grounding 生成具体输入）；
   * `Action` -> 操作序列（mapAction 将表达式映射为可执行动作）；
   * `ExpectedOutcome` -> 断言（oracle）在执行后对系统状态判定真/假。
     运行流程：**Grounding -> 执行 Action -> 断言检查**，详见第3节。
4. **可测试性约束**：一组 OCL 约束（见第4节），用于自动判定规则是否满足可测试性条件（结构完整、值类型合规、断言/动作可判定/可执行等）。

---

# 6. 示例：将自然语言规则转为 TRL 实例，并判断可测试性

选取法律文本中的**一条自然语言规则**（原文节选）：

> “机动车上道路行驶，不得超过限速标志标明的最高时速。在没有限速标志的路段，应当保持安全车速。”（《中华人民共和国道路交通安全法》 第四十二条）

我们采用 TRL 将其规范化为两条规则 R1（关于限速标志）与 R2（无标志时的安全速）——这里只给 R1 的完整 TRL 实例并用上传的测试用例进行校验（`testcase_traffic.json` 中有与限速相关的条目）。

## 6.1 自然语言 → TRL（规则 R1）

**NL**：机动车上道路行驶，不得超过限速标志标明的最高时速。
**TRL（BNF 格式）**：

```
IF (Actor = "机动车" AND Action = "行驶" AND Location = "道路" AND Speed > LimitSign)
AND Action = "行驶"
THEN (Outcome = "违章超速" AND ExpectedPenalty = "按法律处理")
```

但按照我们必须的统一表达形式（Condition、Action、ExpectedOutcome 结构一致），更精确如下（字段值为字符串或数字；LimitSign 用数字表示限制值；若 LimitSign 未指定则为缺省）：

**实例（更严格的 TRL）**：

```
Rule:
IF (Actor = "机动车" AND Action = "行驶" AND Location = "路段" AND LimitSign IS_PRESENT = true AND Speed > LimitSignValue)
AND (Action = "行驶" AND Speed = SpeedValue)
THEN (Outcome = "超速被判定" AND Amount = PenaltyAmount)
```

为保持 BNF 语法约定的 `<Atom>` 表达，这里写成具体的表达式（假定限速牌值为 60）：

```
IF (Actor = "机动车" AND Action = "行驶" AND Location = "有限速标志" AND Speed > 60)
AND (Action = "行驶")
THEN (Outcome = "违章超速" AND Amount >= 0)
```

> 说明：`LimitSignValue` 可以是变量/占位符，Grounding 阶段会被具体化为数字（例如 60、100）。

## 6.2 使用上传的测试用例进行匹配与判定

在你上传的 `testcase_traffic.json` 中，有一个测试条目（第二项）：

```json
{
  "主体": "机动车",
  "操作": "行驶",
  "速度": 80,
  "限制": "禁止",
  "预期结果": "失败"
}
```

（文件已引用。）

将该 JSON 映射到 TRL 字段（中文字段映射）：

* Actor = "机动车"
* Action = "行驶"
* Speed = 80
* （假如上下文或元数据指出该路段限速为 60，则 Speed > LimitSignValue 成立）

**判定流程**：

1. Grounding：Condition `Actor="机动车" AND Action="行驶" AND Speed>60` 在测试用例上成立（80>60）。
2. Action 执行：执行 `行驶`（模拟或记录）。
3. Outcome 判定：ExpectedOutcome 为 `违章超速`，测试用例预期 "失败"（意味着测试应判定为规则生效/违规），与我们的 `Outcome="违章超速"` 对应，断言成立（系统应认定违规）。

**结论（可测试性）**：

* 该 TRL 实例满足 OCL 约束：包含 Precondition/Operation/ExpectedResult，叶子值为字符串/数字，Outcome 可判定。故 **可测试**。
* 对应上传的测试用例第2项与之匹配，并且测试用例表明 `预期结果: 失败`（即违规），这与规则 R1 的 ExpectedOutcome 一致，因此测试用例可被用于验证 R1。

## 6.3 另一个示例：高速公路故障设置警示标志（法律中明确 150 米）

法律第六十八条：`警告标志应当设置在故障车来车方向一百五十米以外`（高速公路）

**TRL 表达**：

```
IF (Actor = "机动车" AND Location = "高速公路" AND Event = "故障")
AND (Action = "设置" AND Target = "标志" AND Distance = 150)
THEN (Outcome = "设置标志完成")
```

在 `testcase_traffic.json` 有匹配项（第6条）：

```json
{
  "主体": "机动车",
  "条件": "故障",
  "位置": "高速公路",
  "操作": "设置",
  "对象": "标志",
  "距离": 150,
  "限制": "必须",
  "预期结果": "成功"
}
```

该测试用例完全具体化了条件与动作，满足 OCL 约束，可直接用于自动化执行与断言（检查是否设置警示标志且距离≥150）。

---

# 7. 从 TRL 到自动生成测试用例的算法概要（实现提示）

为便于实现端将 TRL 自动转成可执行测试用例/断言，提供一个高层算法：

1. **解析**：解析 Rule 的 `ConditionExpr`、`ActionExpr`、`OutcomeExpr`（使用 BNF）。
2. **校验 OCL**：对解析后的 AST 应用 OCL 约束，若不满足则标记不可测试并报告原因。
3. **Grounding**：对 `Condition` 内每个原子：

   * 如果是 `field = string/number`，直接用该值；
   * 如果是比较（`>`, `<`），生成边界值、典型值（如若需要多个测试），或从历史用例（`testcase_traffic.json`）中抽取具体值。
4. **映射 Action -> 操作序列**：根据 Operation 中字段构造执行函数/API 调用（例如 `placeWarning(distance=150)`）。
5. **构造断言**：将 `Outcome` 转换为断言函数（例如 `assert(warning_set and warning_distance >= 150)`）。
6. **生成测试用例格式**：把 Input、Action、ExpectedOutcome 打包成 JSON（同 `testcase_traffic.json` 结构），供执行器执行与判定。

---

# 8. 小结（可落地要点）

* TRL 提供了**统一的三段式表达**（Condition / Action / ExpectedOutcome）并将三者语法统一为 `<Expr>`，便于自动解析和一致化处理。
* 通过明确的符号系统与禁止 enum 的值策略，保证了转换与 Grounding 的可操作性。
* 采用 OCL 约束来机械化判定“可测试性”，并给出多个关键约束（结构、值类型、可断言性、嵌套深度等）。
* 用你提供的法律文本与测试用例做了两处实例化演示（限速与高速故障 150m），并指出这些测试用例如何与 TRL 对应、如何满足可测试性。原始文件与用例见：法律文档与 `testcase_traffic.json`。

---

# 附录：便于实现的短列表（工程提示）

* 解析器：基于 BNF 实现 LL(*) 或 ANTLR 文法；确保字符串值允许中文/空格。
* Grounding 策略：支持“从用例抽取”、“枚举边界”、“随机采样 + 约束求解器（SMT 或 CSP）”三类策略。
* Action 映射表：为常见动作（行驶、超车、设置标志、停车、驾驶）定义可执行模板 `mapAction`。
* 断言库：提供常用断言模板（速度比较、距离比较、标志存在与否、证件存在与否）。
* 可测试性报告：若 OCL 约束失败，返回可修正建议（例如“ExpectedOutcome 缺乏可判定字段 Amount 或 Outcome”）。

---

如果你愿意，我可以：

* 把上面 BNF 和 OCL 自动生成一个机器可读的 grammar + 校验器草稿（例如 ANTLR 语法与 OCL 规则脚本），或者
* 将你 `testcase_traffic.json` 中每条测试用例自动转换为 TRL 实例（输出一组 JSON-TRL 对应），并标注哪些用例通过/未通过 OCL 可测试性校验（我可以现在就为你完成：将全部测试用例逐条转换并给出可测试性判定与失败原因）。

你想先把 `testcase_traffic.json` 的所有条目映射为 TRL 实例并校验吗？（我可以直接做并把结果给你。）
