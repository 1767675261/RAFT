


def get_prompt(metamodel = ""):
    metamodel_prompt = """你是一名 **软件需求建模与测试专家**。我将提供两类输入：
1. 一篇 **领域的规则文档**；
2. 它对应的 **部分测试用例**。

你的任务是为**领域**的规则构建一个领域元模型(metamodel)，该元模型以类图风格的树结构描述规则的语法。要求元模型构建分两步完成：第一步提取并确认规则要素（15-20个叶子要素）；第二步基于这些要素构建三层元模型，并把这些要素分别与前置条件、操作步骤、预期结果建立关系。

请严格遵守下列规范与输出格式——严格、完整、可机读：

### 元模型构建规范（必须遵守）
1. **总体结构**
   * 元模型为树结构，采用类图风格（仅类与关系，不包含类属性或方法）。
   * 必须采用三层结构：顶层（1节点）→中间层（固定为3个节点）→底层（n个叶子节点）。
   * 顶层节点固定为`Rule`（单一类）。
   * 中间层固定为三个类：`Precondition`、`Operation`、`ExpectedResult`（分别对应“前置条件、操作步骤、预期结果”）。
   * 底层为最小规则要素（叶子节点，见第2节）。

2. **叶子节点（规则要素）要求**
   * 必须是可测试的、可量化、具体的规则要素。
   * 要素总数必须在15个左右。高频/核心要素单独列出；语义重叠的要素合并；零散且低频的要素合并为通用叶子`Constraint`。注意：Precondition、Operation和ExpectedResult都需要包含`Constraint`。
   * 叶子节点为要素名称（key），禁止包含具体值或示例（如“利率”正确，“年利率5%”错误）。
   * 优先从测试用例提取，结合规则文档补充完整。测试用例中“规则元素1/规则元素2”形式需合并为同一要素。
   * 要素需具备领域内复用性，能覆盖同一领域不同规则文档的共性要素。

3. **关系**
   * 关系类型及适用场景：
     * `contains`（包含）— 中层节点对底层要素的组成关系
     * `constrains`（约束）— 要素对节点/另一要素的限制关系
     * `dependsOn`（依赖）— 要素运行时的前提关系
     * `triggers`（触发）— 操作对预期结果的引发关系
     * 其他关系
   * 每条关系在PlantUML中必须标注关系名。
   * 底层要素仅能与中层三个节点中的一个建立关系，关系类型需匹配要素语义。请仔细思考每个规则要素属于前置条件，还是操作步骤，还是预期结果。

4. **两步输出要求**
   * **步骤一（Step1 — 规则要素清单）**：以列表形式列出15个左右的叶子类（类名使用UpperCamelCase），每个要素需附加10字以内的语义说明。
   * **步骤二（Step2 — 元模型）**：使用PlantUML构建完整三层结构类图：
     * 顶层`Rule`；
     * 中层`Precondition`、`Operation`、`ExpectedResult`；
     * 底层直接引用Step1中的叶子类，禁止重命名。
   * Step2中需明确所有关系的连接方向和类型，确保树状分层且关系逻辑自洽。

5. **命名与风格**
   * 所有类名使用UpperCamelCase（如`AccountStatus`而非`account_status`）。
   * 类体保持空白（仅类名）。
   * 关系名使用小写动词（如`contains`、`triggers`）。

### 输出（强制）
* 规则要素清单以编号列表形式输出；元模型输出PlantUML代码（用```plantuml和```包裹）。
* 叶子节点数量严格控制在15个左右；Step1与Step2中的叶子类名称必须完全一致（含大小写）。
* 如果不知道有哪些要素，参考测试用例的key，要素必须精简、有代表性、高频，例如只能有一个Actor主体，不能有X主体、Y主体等，这都太重复了。"""

    representation_prompt = """你是一名 **软件需求建模与测试专家**。
你的任务是：**定义一种用于描述可测试规则的形式化语言（Testable Rule Language, TRL）**。
该语言旨在将自然语言规则或需求文档形式化，使其能够被自动解析、验证和生成测试用例。

---

### 输入

你将获得以下三类输入：

1. **规则/需求文档** —— 包含领域规则或系统行为的自然语言描述；
2. **测试用例** —— 对应文档中规则的实际测试样例；
3. **元模型语法结构** —— 描述规则由哪些要素组成及其层级关系。

---

### 任务目标

请基于以上输入，**定义完整的可测试规则语言 TRL**。
语言定义包括 **四个部分：符号 (Symbols)、语法 (Syntax)、语义 (Semantics)、可测试性约束 (Testability Constraints)**。
每个部分的要求如下：

---

### **符号系统 (Symbols)**

* 以给定的元模型为基础，定义语言中使用的符号类型与作用范围，包括：
  * **逻辑符号**
  * **比较符号**
  * **领域符号**
* 明确每类符号的语法位置与语义角色。

---

### **语法 (Syntax)**

* 以给定的元模型为基础，定义语言的核心组成单元，同时指出这些单元的层次结构与组合规则；
* 每个元素的值应该是字符串或数字，不能是enum；
* 使用形式化BNF表示定义语言结构，顶层结构为下面格式，禁止修改；
  ```
  Rule ::= "IF" <Condition> "AND" <Action> "THEN" <ExpectedOutcome>
  ```
* 语法定义尽量简单直接，但要支持复杂规则（如同一要素或不同要素间的与或非、嵌套条件、复合动作）；
* Condition、Action和ExpectedOutcome应该具有一致的表达形式，相同的结构风格。

---

### **语义 (Semantics)**

* 定义每个语法要素和符号的语义解释；
* 说明如何从语言表达式推导出系统可执行行为：
  * 条件部分映射为输入约束；
  * 动作部分映射为操作序列；
  * 预期结果映射为断言；
* 可使用**操作语义 (Operational Semantics)** 或 **模型语义 (Denotational Semantics)** 表示；

---

### **可测试性约束 (Testability Constraints) — 保证可测试性**

* 定义一组形式化约束，确保规则模型满足**可测试性条件**。你需要根据已有的知识结合文档、测试用例等全面定义可测试规则的条件，并以OCL进行形式化表示。

---

### **输出要求**

请输出以下内容：

1. **符号、语法、语义、可测试性约束每部分的形式化表示**；
2. **TRL 的完整定义**；
3. **一个示例**：展示如何将自然语言规则转化为该语言实例，并判断是否满足可测试性。


### 元模型（PlantUML表示）
{}""".format(metamodel)

    return {
        "meta_model": metamodel_prompt,
        "representation": representation_prompt
    }